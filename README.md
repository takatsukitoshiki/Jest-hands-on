# Jest-hands-on

Jestを扱えるようになるための入門用ハンズオンです。
Jestって何？といったところから関数のmock化までを手を動かしながら学んでいきます。
【内容】

1. Jestとは何か
2. Jestの導入方法
3. テスト作成と実行
4. assertionについて
5. mockについて
6. 非同期関数のテスト

事前に以下の環境を用意しておきます。
// TODO（wsl2のイメージを共有する方法を確認する）
【環境】
os : ubuntu18 (wsl2)
execution env : node.js version12
editor : vscode

## 1. Jestとは何か

JestはFacebook社によって開発されているJavascript用のテストフレームワークです。
Javascriptにおける単体テスト用フレームワークはMocha, Jasmine等がありますが、
ここ数年で急成長しているのがJestであり、現在では使用率No1となっています。
(最近ではStorybookや)

## 2. Jestの導入方法

導入は簡単です。
以下のコマンドをプロジェクトディレクトリで実行しましょう。

`npm install --save-dev jest`

※ --save-devをつけることで開発用のパッケージとしてインストールします。

あとは、テスト対象とそれをテストするコードを用意すればjestを使った単体テストが実施できます。

## 3. テスト作成

では早速、テストを作成していきましょう。
といってもテストする対象がないと何をテストするのかという話になるので、まずは適当にテスト対象となるモジュールを作成します。

まずはモジュール作成する場所”src”ディレクトリを作成しましょう。
作成したら、その場所に"main.js"という名前でJavascriptファイルを作成してください。

main.jsの中身は、とりあえず以下の様に書いておきましょう。

```node.js
main();

function main() {
    console.log("hello world")
}
```

試しに動かして見ましょう。

vscode上でショートカットキー「ctrl + shift + @」を押してみてください。
ターミナルが表示されるはずです。
ちなみに「ctrl + shift + p」と押したあとに「create new terminal」などとしても表示できます。

ターミナルが表示されたら、そこに以下のコマンドを入力して実行してみてください。

`node ./src/main.js`

実行するとターミナルで"hello world!!!"が確認できると思います。

では、このmain関数で表示させる文言を、ある計算結果となるように変えてみます。

```
main();

function main() {
    // console.log("hello world")
    const a = 1;
    const b = 2;
    const result = sum(a, b);
    console.log(a, "+", b, "の合計は", result, "です。");
}

function sum(a, b) {
    return a + b;
}
```

これで足し算の結果が表示されるようになりました。

でも、新たに作成した関数sumの結果が意図した通りになっているか、不安はありませんか？
いま作成した関数は非常に簡単なロジックなのであまりそういった感覚はないかもしれません。
ただ、実際はより複雑で条件分岐なども含まれることになります。
そういった時に有用なのが単体テストというわけです。

それでは、関数sumについてのテストコードを書いていきましょう。

新たに、テストファイル用のディレクトリを作成します。
既に作成してあるsrcと同じ階層に"test"という名前で作成しましょう。

testディレクトリを作成したら、そこに"main.test.js"という名前のファイルを作成してください。
※作成するテストファイルは必ず、拡張子".js"の前に".test"とつけるようにしてください。

作成した"main.test.js"の中身は以下のようにします。

```
const { sum } = require('../src/main2');

describe("test sum", () => {
    test('adds 1 + 2 to equal 3', () => {
        expect(sum(1, 2)).toBe(3);
    });
})
```

テストを実行してみましょう。

`npm run test`

おそらくテストは失敗すると思います。
今コードではテスト対象のsumを外部から扱えないためです。
外部から扱える様にするために、main.jsに書いた関数sumをexportします。

main.jsの最後に以下の一文を加えてください。

`module.exports = { sum };`

では、テストを再実行します。
今度は成功するはずです。

以上で、簡単ではありますが、テストの実行ができました。
テストファイルの内容を説明すると、
まず1行目で、外部モジュールの関数をrequire（インポート）しています。
3行目のdescribeはグルーピングを行っているだけで、この範囲は～～のためのテストといった具合にわかりやすくするためのものです。

4行目からのtestはテストの具体的な処理を記述します。
例では1つのみですが、並列する形でいくつでも記載できます。

5行目ではテスト結果の検証をしています。
expect()に検証対象を与え、続くtoBe()で検証します。
toBe()はマッチャ（matcher）と呼ばれる実行結果を検証するための関数ですが、
toBe()以外にもたくさんの種類があり、必要に応じて使い分けます。

マッチャーについては次項で説明します。


## 4. assertionについて

テストではある関数がどのような結果になるのかを、あらかじめ期待値として定義します。
そして、実際に実行した結果、期待値を満たすかどうかを検証します。
期待値としては様々なケースが考えられます。
同じ関数でも複数あるのが普通です。
場合によってはエラーとなることが期待値であることもあります。

いくつかサンプルをあげてみます。
・toBeNull()
結果がnullであることを期待します
・toBeTruthy()
結果がTrueであることを期待します。
・toStrictEqual(value)
オブジェクトの中身を細かく精査します。すべての項目名や値が一致しなければOKとなりません。
・toThrow(error?)
エラーが発生することを期待します。引数にエラーオブジェクトを与えることで、発生したエラーについても検証します。
・toHaveBeenCalledTimes(number)
対象の関数が指定の回数呼ばれることを期待します。モックを対象に使用します。
・toHaveBeenCalledWith(arg1, arg2, ...)
対象の関数が指定の引数で呼ばれることを期待します。モックを対象に使用します。

他にもたくさんの種類があるので、一度下記のURLを確認してみてください。
https://jestjs.io/docs/ja/expect

練習として、いくつかのマッチャーを使用してみましょう。

main3.jsとmain3.test.js

テストが増えてくると、テストを作成するたびにすべてのテストが実行されることが煩わしいと思うようになります。
そこで、目的のテストだけ実行させるようにしてみます。
そのためには、実行させたいtestに"only"とつけます。つまりtest.only()とします。
describe単位で制限したいのであれば、describe.onlyとします。
逆に、あるテストだけ実行させたくないのであれば、そのテストにskipとつけます。

## 5. mockについて

もしあるモジュールのテストを行いたい時に、そのモジュールが別のモジュールに依存していたとします。
その場合において、別のモジュールが動かないことには目的のテストを実施することができません。
依存モジュールが作成中であれば完成を待つ必要がでてきます。
依存モジュールが正しく動作する場合でも、ある特定の値を返して欲しいと思うこともあるでしょう。
そういった場合に、依存モジュールを都合の良い存在（偽物、モック）に置き換えてテスト対象のみに集中できるようにします。

ここではJestでモック化を行う方法を学びます。

まずは、今までテスト対象としていたmain.jsを別のモジュールに依存する様に変更します。
依存モジュールとして、srcディレクトリ配下に"sub.js"を作成しましょう。

sub.jsにはpeapleオブジェクトを格納する配列を受け取って、指定されたkeyとそのvalueを持つpeapleオブジェクトだけの配列を返す関数filterPeaples()を定義してみます。

この関数をmain.jsで使用するわけです。
ですので、main.jsにも関数countSpecificPeaple()を作成して、その中で先程作成したfilterPeaples()を呼ぶようにします。

では作成したcountSpecificPeaple()が正しく動いているか確認しましょう。
testディレクトリ配下に"main4.test.js"を作成します。

main4.test.jsではテスト対象の関数にわたすpeapleオブジェクトを作成します。
そしてtest内で、テスト対象関数countSpecificPeaple()を呼び出し、peapleオブジェクトの他、keyとvalueの値を渡します。
その結果、今回のケースの場合は2が帰ってくればOKになります。

テストを実行してみましょう。
なんとなくうまく行っているように見えていますが、もしかするとどこかに問題があるかもしれません。
問題があるとすると、それがcountSpecificPeaple()にあるかもしれないし、filterPeaples()にあるかもしれません。
今テストしたいのはcountSpecificPeaple()なので、あまりfilterPeaples()の事は考えたくありませんよね。
というわけで、filterPeaples()を100% 2つのオブジェクトを持つ配列を返すようにしてみましょう。
countSpecificPeaple()としては正しくカウントできていれば良いわけですから、filterPeaples()が正しくフィルターできているかどうかは二の次です。

どうすれば良いか。filterPeaples()をモック化します。

やり方は簡単です。
モック化する対象モジュールをrequireしたあとに、対象の関数に対してjest.fn()とするだけ。
これで、sub.filterPeaples()はモックになりました。

※モック化の方法は同じことをするにしても何通りかあるので、ちょっと分かりづらいところがあります。

ただし、ただモック化しただけなので、何も中身のないただの偽物です。
今回は「100% 2つのpeapleオブジェクトを持つ配列を返す」関数にしたいわけなので、もうひと工夫が必要です。

モック化したあとに続けて、以下の様に書きます。

```
sub.filterPeaples.mockReturnValue([{ name: "tanaka" }, { name: "yamada" }])
```

確認も兼ねて、sub.filterPeaples()をコンソール出力してみましょう。
引数に関係なく同じ値が返ってくるはずです。

追加で書いた、mockReturnValue()はモックが呼ばれる度に返す値を設定します。
もっと詳しく挙動を設定したい場合は、例えば以下の様に書きます。
```
sub.filterPeaples = jest.fn(() => {
    ~~処理の詳細~~
})
```

また、モックは呼び出し回数なども記録しているので、
何回、どのような引数で呼び出されたかも検証することができます。
テストでは、モック化した関数が一度だけ呼び出されたことを検証してみます。

その他、コールバックをモック化して、どのようにコールバックが扱われたかといったことにも使用できます。

https://jestjs.io/docs/ja/mock-function-api

## 6. 非同期関数のテスト

Javascriptといえば非同期ですが、非同期の場合ももちろん検証可能です。
非同期に関してサンプルで確認してみましょう。
callbackを受け取る非同期関数を検証する場合、これまでと同じ様に書いてしまうと、
非同期関数を呼んだ直後にテストが終了してしまいます。
この場合は、コールバック内でdone()を呼び事でテスト実行終了を待ってくれるようになります。
また、Promiseを返す非同期関数のテストでは、Promiseをreturnすることで、jestはその解決を待ちます。
awaitを使用する方法もあります。
